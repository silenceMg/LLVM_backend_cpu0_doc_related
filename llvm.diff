diff -Nrup orig/llvm/CMakeLists.txt modify/llvm/CMakeLists.txt
--- orig/llvm/CMakeLists.txt	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/CMakeLists.txt	2023-04-26 15:15:07.000000000 +0800
@@ -297,6 +297,7 @@ set(LLVM_ALL_TARGETS
   Hexagon
   Lanai
   Mips
+  Cpu0
   MSP430
   NVPTX
   PowerPC
diff -Nrup orig/llvm/cmake/config-ix.cmake modify/llvm/cmake/config-ix.cmake
--- orig/llvm/cmake/config-ix.cmake	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/cmake/config-ix.cmake	2023-04-26 15:15:07.000000000 +0800
@@ -433,6 +433,8 @@ elseif (LLVM_NATIVE_ARCH MATCHES "avr")
   set(LLVM_NATIVE_ARCH AVR)
 elseif (LLVM_NATIVE_ARCH MATCHES "mips")
   set(LLVM_NATIVE_ARCH Mips)
+elseif (LLVM_NATIVE_ARCH MATCHES "cpu0")
+  set(LLVM_NATIVE_ARCH Cpu0)
 elseif (LLVM_NATIVE_ARCH MATCHES "xcore")
   set(LLVM_NATIVE_ARCH XCore)
 elseif (LLVM_NATIVE_ARCH MATCHES "msp430")
diff -Nrup orig/llvm/include/llvm/ADT/Triple.h modify/llvm/include/llvm/ADT/Triple.h
--- orig/llvm/include/llvm/ADT/Triple.h	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/include/llvm/ADT/Triple.h	2023-04-26 15:15:07.000000000 +0800
@@ -15,6 +15,7 @@
 // this file.  Undefine them here.
 #undef NetBSD
 #undef mips
+#undef cpu0
 #undef sparc
 
 namespace llvm {
@@ -62,6 +63,8 @@ public:
     mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el
     mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6
     mips64el,       // MIPS64EL: mips64el, mips64r6el, mipsn32el, mipsn32r6el
+    cpu0,           // For Tutorial Backend Cpu0
+    cpu0el,
     msp430,         // MSP430: msp430
     ppc,            // PPC: powerpc
     ppcle,          // PPCLE: powerpc (little endian)
diff -Nrup orig/llvm/include/llvm/BinaryFormat/ELF.h modify/llvm/include/llvm/BinaryFormat/ELF.h
--- orig/llvm/include/llvm/BinaryFormat/ELF.h	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/include/llvm/BinaryFormat/ELF.h	2023-04-26 15:15:07.000000000 +0800
@@ -317,6 +317,7 @@ enum {
   EM_BPF = 247,           // Linux kernel bpf virtual machine
   EM_VE = 251,            // NEC SX-Aurora VE
   EM_CSKY = 252,          // C-SKY 32-bit processor
+  EM_CPU0 = 999,          // Document LLVM Backend Tutorial Cpu0
 };
 
 // Object file classes.
@@ -584,6 +585,19 @@ enum {
   ODK_PAGESIZE = 11   // Page size information
 };
 
+// Cpu0 Specific e_flags
+enum {
+  EF_CPU0_NOREORDER = 0x00000001, // Don't reorder instructions
+  EF_CPU0_PIC       = 0x00000002, // Position independent code
+  EF_CPU0_ARCH_32   = 0x50000000, // CPU032 instruction set per linux not elf.h
+  EF_CPU0_ARCH      = 0xf0000000  // Mask for applying EF_CPU0_ARCH_ variant
+};
+
+// ELF Relocation types for Cpu0
+enum {
+#include "ELFRelocs/Cpu0.def"
+};
+
 // Hexagon-specific e_flags
 enum {
   // Object processor version flags, bits[11:0]
diff -Nrup orig/llvm/include/llvm/BinaryFormat/ELFRelocs/Cpu0.def modify/llvm/include/llvm/BinaryFormat/ELFRelocs/Cpu0.def
--- orig/llvm/include/llvm/BinaryFormat/ELFRelocs/Cpu0.def	1970-01-01 08:00:00.000000000 +0800
+++ modify/llvm/include/llvm/BinaryFormat/ELFRelocs/Cpu0.def	2023-04-26 15:15:07.000000000 +0800
@@ -0,0 +1,29 @@
+
+#ifndef ELF_RELOC
+#error "ELF_RELOC must be defined"
+#endif
+
+ELF_RELOC(R_CPU0_NONE,                0)
+ELF_RELOC(R_CPU0_32,                  2)
+ELF_RELOC(R_CPU0_HI16,                5)
+ELF_RELOC(R_CPU0_LO16,                6)
+ELF_RELOC(R_CPU0_GPREL16,             7)
+ELF_RELOC(R_CPU0_LITERAL,             8)
+ELF_RELOC(R_CPU0_GOT16,               9)
+ELF_RELOC(R_CPU0_PC16,               10)
+ELF_RELOC(R_CPU0_CALL16,             11)
+ELF_RELOC(R_CPU0_GPREL32,            12)
+ELF_RELOC(R_CPU0_PC24,               13)
+ELF_RELOC(R_CPU0_GOT_HI16,           22)
+ELF_RELOC(R_CPU0_GOT_LO16,           23)
+ELF_RELOC(R_CPU0_RELGOT,             36)
+ELF_RELOC(R_CPU0_TLS_GD,             42)
+ELF_RELOC(R_CPU0_TLS_LDM,            43)
+ELF_RELOC(R_CPU0_TLS_DTP_HI16,       44)
+ELF_RELOC(R_CPU0_TLS_DTP_LO16,       45)
+ELF_RELOC(R_CPU0_TLS_GOTTPREL,       46)
+ELF_RELOC(R_CPU0_TLS_TPREL32,        47)
+ELF_RELOC(R_CPU0_TLS_TP_HI16,        49)
+ELF_RELOC(R_CPU0_TLS_TP_LO16,        50)
+ELF_RELOC(R_CPU0_GLOB_DAT,           51)
+ELF_RELOC(R_CPU0_JUMP_SLOT,          127)
diff -Nrup orig/llvm/include/llvm/IR/Intrinsics.td modify/llvm/include/llvm/IR/Intrinsics.td
--- orig/llvm/include/llvm/IR/Intrinsics.td	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/include/llvm/IR/Intrinsics.td	2023-04-26 15:15:07.000000000 +0800
@@ -1658,6 +1658,7 @@ include "llvm/IR/IntrinsicsXCore.td"
 include "llvm/IR/IntrinsicsHexagon.td"
 include "llvm/IR/IntrinsicsNVVM.td"
 include "llvm/IR/IntrinsicsMips.td"
+include "llvm/IR/IntrinsicsCpu0.td"
 include "llvm/IR/IntrinsicsAMDGPU.td"
 include "llvm/IR/IntrinsicsBPF.td"
 include "llvm/IR/IntrinsicsSystemZ.td"
diff -Nrup orig/llvm/include/llvm/IR/IntrinsicsCpu0.td modify/llvm/include/llvm/IR/IntrinsicsCpu0.td
--- orig/llvm/include/llvm/IR/IntrinsicsCpu0.td	1970-01-01 08:00:00.000000000 +0800
+++ modify/llvm/include/llvm/IR/IntrinsicsCpu0.td	2023-04-26 15:15:07.000000000 +0800
@@ -0,0 +1,18 @@
+//===- IntrinsicsCpu0.td - Defines Mips intrinsics ---------*- tablegen -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines all of the CPU0-specific intrinsics.
+//
+//===----------------------------------------------------------------------===//
+
+// __builtin_cpu0_gcd defined in
+// https://github.com/Jonathan2251/lbt/blob/master/exlbt/clang/include/clang/Basic/BuiltinsCpu0.def
+def int_cpu0_gcd : GCCBuiltin<"__builtin_cpu0_gcd">,
+  Intrinsic<[llvm_i32_ty], [llvm_i32_ty, llvm_i32_ty],
+  [Commutative, IntrNoMem]>;
diff -Nrup orig/llvm/include/llvm/Object/ELFObjectFile.h modify/llvm/include/llvm/Object/ELFObjectFile.h
--- orig/llvm/include/llvm/Object/ELFObjectFile.h	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/include/llvm/Object/ELFObjectFile.h	2023-04-26 15:15:07.000000000 +0800
@@ -1157,6 +1157,8 @@ StringRef ELFObjectFile<ELFT>::getFileFo
       return "elf32-lanai";
     case ELF::EM_MIPS:
       return "elf32-mips";
+    case ELF::EM_CPU0:	// llvm-objdump -t -r
+      return "ELF32-cpu0";
     case ELF::EM_MSP430:
       return "elf32-msp430";
     case ELF::EM_PPC:
@@ -1233,6 +1235,13 @@ template <class ELFT> Triple::ArchType E
     default:
       report_fatal_error("Invalid ELFCLASS!");
     }
+  case ELF::EM_CPU0:	// llvm-objdump -t -r
+    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {
+    case ELF::ELFCLASS32:
+      return IsLittleEndian ? Triple::cpu0el : Triple::cpu0;
+    default:
+      report_fatal_error("Invalid ELFCLASS!");
+    }
   case ELF::EM_MSP430:
     return Triple::msp430;
   case ELF::EM_PPC:
diff -Nrup orig/llvm/include/llvm/module.modulemap modify/llvm/include/llvm/module.modulemap
--- orig/llvm/include/llvm/module.modulemap	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/include/llvm/module.modulemap	2023-04-26 15:15:07.000000000 +0800
@@ -71,6 +71,7 @@ module LLVM_BinaryFormat {
     textual header "BinaryFormat/ELFRelocs/i386.def"
     textual header "BinaryFormat/ELFRelocs/Lanai.def"
     textual header "BinaryFormat/ELFRelocs/Mips.def"
+    textual header "BinaryFormat/ELFRelocs/Cpu0.def"
     textual header "BinaryFormat/ELFRelocs/MSP430.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC64.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC.def"
diff -Nrup orig/llvm/lib/MC/MCSubtargetInfo.cpp modify/llvm/lib/MC/MCSubtargetInfo.cpp
--- orig/llvm/lib/MC/MCSubtargetInfo.cpp	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/lib/MC/MCSubtargetInfo.cpp	2023-04-26 15:15:07.000000000 +0800
@@ -55,6 +55,8 @@ void ClearImpliedBits(FeatureBitset &Bit
   }
 }
 
+bool Cpu0DisableUnreconginizedMessage = false;
+
 static void ApplyFeatureFlag(FeatureBitset &Bits, StringRef Feature,
                              ArrayRef<SubtargetFeatureKV> FeatureTable) {
   assert(SubtargetFeatures::hasFlag(Feature) &&
@@ -78,8 +80,9 @@ static void ApplyFeatureFlag(FeatureBits
       ClearImpliedBits(Bits, FeatureEntry->Value, FeatureTable);
     }
   } else {
-    errs() << "'" << Feature << "' is not a recognized feature for this target"
-           << " (ignoring feature)\n";
+    if (!Cpu0DisableUnreconginizedMessage) // For Cpu0
+      errs() << "'" << Feature << "' is not a recognized feature for this target"
+             << " (ignoring feature)\n";
   }
 }
 
@@ -185,7 +188,7 @@ static FeatureBitset getFeatures(StringR
     if (CPUEntry) {
       // Set the features implied by this CPU feature, if any.
       SetImpliedBits(Bits, CPUEntry->TuneImplies.getAsBitset(), ProcFeatures);
-    } else if (TuneCPU != CPU) {
+    } else if (TuneCPU != CPU && CPU != "mips32r2"/* For Cpu0*/) {
       errs() << "'" << TuneCPU << "' is not a recognized processor for this "
              << "target (ignoring processor)\n";
     }
@@ -207,6 +210,11 @@ static FeatureBitset getFeatures(StringR
 
 void MCSubtargetInfo::InitMCProcessorInfo(StringRef CPU, StringRef TuneCPU,
                                           StringRef FS) {
+  #if 1 // Disable reconginized processor message. For Cpu0
+  if (TargetTriple.getArch() == llvm::Triple::cpu0 ||
+      TargetTriple.getArch() == llvm::Triple::cpu0el)
+    Cpu0DisableUnreconginizedMessage = true;
+  #endif
   FeatureBits = getFeatures(CPU, TuneCPU, FS, ProcDesc, ProcFeatures);
   if (!TuneCPU.empty())
     CPUSchedModel = &getSchedModelForCPU(TuneCPU);
@@ -279,8 +287,9 @@ FeatureBitset MCSubtargetInfo::ToggleFea
                      ProcFeatures);
     }
   } else {
-    errs() << "'" << Feature << "' is not a recognized feature for this target"
-           << " (ignoring feature)\n";
+    if (!Cpu0DisableUnreconginizedMessage) // For Cpu0
+      errs() << "'" << Feature << "' is not a recognized feature for this target"
+             << " (ignoring feature)\n";
   }
 
   return FeatureBits;
@@ -312,9 +321,13 @@ const MCSchedModel &MCSubtargetInfo::get
 
   if (!CPUEntry) {
     if (CPU != "help") // Don't error if the user asked for help.
-      errs() << "'" << CPU
-             << "' is not a recognized processor for this target"
-             << " (ignoring processor)\n";
+      #if 1 // Disable reconginized processor message. For Cpu0
+      if (TargetTriple.getArch() != llvm::Triple::cpu0 &&
+          TargetTriple.getArch() != llvm::Triple::cpu0el)
+      #endif
+        errs() << "'" << CPU
+               << "' is not a recognized processor for this target"
+               << " (ignoring processor)\n";
     return MCSchedModel::GetDefaultSchedModel();
   }
   assert(CPUEntry->SchedModel && "Missing processor SchedModel value");
diff -Nrup orig/llvm/lib/Object/ELF.cpp modify/llvm/lib/Object/ELF.cpp
--- orig/llvm/lib/Object/ELF.cpp	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/lib/Object/ELF.cpp	2023-04-26 15:15:07.000000000 +0800
@@ -44,6 +44,13 @@ StringRef llvm::object::getELFRelocation
       break;
     }
     break;
+  case ELF::EM_CPU0:
+    switch (Type) {
+#include "llvm/BinaryFormat/ELFRelocs/Cpu0.def"
+    default:
+      break;
+    }
+    break;
   case ELF::EM_AARCH64:
     switch (Type) {
 #include "llvm/BinaryFormat/ELFRelocs/AArch64.def"
diff -Nrup orig/llvm/lib/Support/Triple.cpp modify/llvm/lib/Support/Triple.cpp
--- orig/llvm/lib/Support/Triple.cpp	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/lib/Support/Triple.cpp	2023-04-26 15:15:07.000000000 +0800
@@ -48,6 +48,8 @@ StringRef Triple::getArchTypeName(ArchTy
   case mips64el:       return "mips64el";
   case mips:           return "mips";
   case mipsel:         return "mipsel";
+  case cpu0:           return "cpu0";
+  case cpu0el:         return "cpu0el";
   case msp430:         return "msp430";
   case nvptx64:        return "nvptx64";
   case nvptx:          return "nvptx";
@@ -110,6 +112,9 @@ StringRef Triple::getArchTypePrefix(Arch
   case mips64:
   case mips64el:    return "mips";
 
+  case cpu0:
+  case cpu0el:      return "cpu0";
+
   case hexagon:     return "hexagon";
 
   case amdgcn:      return "amdgcn";
@@ -285,6 +290,8 @@ Triple::ArchType Triple::getArchTypeForL
     .Case("mipsel", mipsel)
     .Case("mips64", mips64)
     .Case("mips64el", mips64el)
+    .Case("cpu0", cpu0)
+    .Case("cpu0el", cpu0el)
     .Case("msp430", msp430)
     .Case("ppc64", ppc64)
     .Case("ppc32", ppc)
@@ -428,6 +435,8 @@ static Triple::ArchType parseArch(String
            "mips64r6", "mipsn32r6", Triple::mips64)
     .Cases("mips64el", "mipsn32el", "mipsisa64r6el", "mips64r6el",
            "mipsn32r6el", Triple::mips64el)
+    .Cases("cpu0", "cpu0eb", "cpu0allegrex", Triple::cpu0)
+    .Cases("cpu0el", "cpu0allegrexel", Triple::cpu0el)
     .Case("r600", Triple::r600)
     .Case("amdgcn", Triple::amdgcn)
     .Case("riscv32", Triple::riscv32)
@@ -707,6 +716,8 @@ static Triple::ObjectFormatType getDefau
   case Triple::mips64el:
   case Triple::mips:
   case Triple::mipsel:
+  case Triple::cpu0:
+  case Triple::cpu0el:
   case Triple::msp430:
   case Triple::nvptx64:
   case Triple::nvptx:
@@ -1278,6 +1289,8 @@ static unsigned getArchPointerBitWidth(l
   case llvm::Triple::le32:
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
+  case llvm::Triple::cpu0:
+  case llvm::Triple::cpu0el:
   case llvm::Triple::nvptx:
   case llvm::Triple::ppc:
   case llvm::Triple::ppcle:
@@ -1362,6 +1375,8 @@ Triple Triple::get32BitArchVariant() con
   case Triple::le32:
   case Triple::mips:
   case Triple::mipsel:
+  case Triple::cpu0:
+  case Triple::cpu0el:
   case Triple::nvptx:
   case Triple::ppc:
   case Triple::ppcle:
@@ -1419,6 +1434,8 @@ Triple Triple::get64BitArchVariant() con
   case Triple::tce:
   case Triple::tcele:
   case Triple::xcore:
+  case Triple::cpu0:
+  case Triple::cpu0el:
     T.setArch(UnknownArch);
     break;
 
@@ -1509,6 +1526,8 @@ Triple Triple::getBigEndianArchVariant()
   // drop any arch suffixes.
   case Triple::arm:
   case Triple::thumb:
+  case Triple::cpu0:
+  case Triple::cpu0el:
     T.setArch(UnknownArch);
     break;
 
@@ -1541,6 +1560,8 @@ Triple Triple::getLittleEndianArchVarian
   // drop any arch suffixes.
   case Triple::armeb:
   case Triple::thumbeb:
+  case Triple::cpu0:
+  case Triple::cpu0el:
     T.setArch(UnknownArch);
     break;
 
@@ -1577,6 +1598,7 @@ bool Triple::isLittleEndian() const {
   case Triple::le64:
   case Triple::mips64el:
   case Triple::mipsel:
+  case Triple::cpu0el:
   case Triple::msp430:
   case Triple::nvptx64:
   case Triple::nvptx:
diff -Nrup orig/llvm/tools/elf2hex/CMakeLists.txt modify/llvm/tools/elf2hex/CMakeLists.txt
--- orig/llvm/tools/elf2hex/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ modify/llvm/tools/elf2hex/CMakeLists.txt	2023-04-26 15:15:07.000000000 +0800
@@ -0,0 +1,32 @@
+# elf2hex.cpp needs backend related functions, like 
+# LLVMInitializeCpu0TargetInfo and LLVMInitializeCpu0Disassembler ... etc.
+# Set LLVM_LINK_COMPONENTS then it can link them during the link stage.
+set(LLVM_LINK_COMPONENTS
+#  AllTargetsAsmPrinters
+  AllTargetsDescs
+  AllTargetsDisassemblers
+  AllTargetsInfos
+  BinaryFormat
+  CodeGen
+  DebugInfoDWARF
+  DebugInfoPDB
+  Demangle
+  MC
+  MCDisassembler
+  Object
+  Support
+  Symbolize
+  )
+
+add_llvm_tool(elf2hex
+  elf2hex.cpp
+  )
+
+if(HAVE_LIBXAR)
+  target_link_libraries(elf2hex PRIVATE ${XAR_LIB})
+endif()
+
+if(LLVM_INSTALL_BINUTILS_SYMLINKS)
+  add_llvm_tool_symlink(elf2hex elf2hex)
+endif()
+
diff -Nrup orig/llvm/tools/elf2hex/elf2hex.cpp modify/llvm/tools/elf2hex/elf2hex.cpp
--- orig/llvm/tools/elf2hex/elf2hex.cpp	1970-01-01 08:00:00.000000000 +0800
+++ modify/llvm/tools/elf2hex/elf2hex.cpp	2023-04-26 15:15:07.000000000 +0800
@@ -0,0 +1,646 @@
+//===-- llvm-objdump.cpp - Object file dumping utility for llvm -----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This program is a utility that works like binutils "objdump", that is, it
+// dumps out a plethora of information about an object file depending on the
+// flags.
+//
+// The flags and output of this program should be near identical to those of
+// binutils objdump.
+//
+//===----------------------------------------------------------------------===//
+
+#define ELF2HEX
+
+#include "elf2hex.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCInstrAnalysis.h"
+#include "llvm/MC/MCInstrInfo.h"
+#include "llvm/MC/MCObjectFileInfo.h"
+#include "llvm/MC/MCTargetOptions.h"
+#include "llvm/Object/MachO.h"
+#include "llvm/Support/InitLLVM.h"
+#include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/TargetSelect.h"
+
+using namespace llvm;
+using namespace llvm::object;
+
+static StringRef ToolName;
+static StringRef CurrInputFile;
+
+// copy from llvm-objdump.cpp
+LLVM_ATTRIBUTE_NORETURN void reportError(StringRef File,
+                                                  const Twine &Message) {
+  outs().flush();
+  WithColor::error(errs(), ToolName) << "'" << File << "': " << Message << "\n";
+  exit(1);
+}
+
+// copy from llvm-objdump.h
+template <typename T, typename... Ts>
+T unwrapOrError(Expected<T> EO, Ts &&... Args) {
+  if (EO)
+    return std::move(*EO);
+  assert(0 && "error in unwrapOrError()");
+}
+
+// copy from llvm-objdump.cpp
+static cl::OptionCategory Elf2hexCat("elf2hex Options");
+
+static cl::list<std::string> InputFilenames(cl::Positional,
+                                            cl::desc("<input object files>"),
+                                            cl::ZeroOrMore,
+                                            cl::cat(Elf2hexCat));
+std::string TripleName = "";
+                                            
+static const Target *getTarget(const ObjectFile *Obj) {
+  // Figure out the target triple.
+  Triple TheTriple("unknown-unknown-unknown");
+  TheTriple = Obj->makeTriple();
+
+  // Get the target specific parser.
+  std::string Error;
+  const Target *TheTarget = TargetRegistry::lookupTarget("", TheTriple,
+                                                         Error);
+  if (!TheTarget)
+    reportError(Obj->getFileName(), "can't find target: " + Error);
+
+  // Update the triple name and return the found target.
+  TripleName = TheTriple.getTriple();
+  return TheTarget;
+}
+
+bool isRelocAddressLess(RelocationRef A, RelocationRef B) {
+  return A.getOffset() < B.getOffset();
+}
+
+void error(std::error_code EC) {
+  if (!EC)
+    return;
+  WithColor::error(errs(), ToolName)
+      << "reading file: " << EC.message() << ".\n";
+  errs().flush();
+  exit(1);
+}
+
+static void getName(llvm::object::SectionRef const &Section, StringRef Name) {
+  Name = unwrapOrError(Section.getName(), CurrInputFile);
+#ifdef ELF2HEX_DEBUG
+  llvm::dbgs() << Name << "\n";
+#endif
+}
+
+
+static cl::opt<bool>
+LittleEndian("le", 
+cl::desc("Little endian format"));
+
+#ifdef ELF2HEX_DEBUG
+// Modified from PrintSectionHeaders()
+uint64_t GetSectionHeaderStartAddress(const ObjectFile *Obj, 
+  StringRef sectionName) {
+//  outs() << "Sections:\n"
+//            "Idx Name          Size      Address          Type\n";
+  std::error_code ec;
+  unsigned i = 0;
+  for (const SectionRef &Section : Obj->sections()) {
+    error(ec);
+    StringRef Name;
+    error(getName(Section, Name));
+    uint64_t Address;
+    Address = Section.getAddress();
+    uint64_t Size;
+    Size = Section.getSize();
+    bool Text;
+    Text = Section.isText();
+    if (Name == sectionName)
+      return Address;
+    else
+      return 0;
+    ++i;
+  }
+  return 0;
+}
+#endif
+
+// Reference from llvm::printSymbolTable of llvm-objdump.cpp
+uint64_t GetSymbolAddress(const ObjectFile *o, StringRef SymbolName) {
+  for (const SymbolRef &Symbol : o->symbols()) {
+    Expected<uint64_t> AddressOrError = Symbol.getAddress();
+    if (!AddressOrError)
+      reportError(o->getFileName(), SymbolName);
+    uint64_t Address = *AddressOrError;
+    Expected<SymbolRef::Type> TypeOrError = Symbol.getType();
+    if (!TypeOrError)
+      reportError(o->getFileName(), SymbolName);
+    SymbolRef::Type Type = *TypeOrError;
+    section_iterator Section = unwrapOrError(Symbol.getSection(), CurrInputFile);
+    StringRef Name;
+    if (Type == SymbolRef::ST_Debug && Section != o->section_end()) {
+      if (Expected<StringRef> NameOrErr = Section->getName())
+        Name = *NameOrErr;
+      else
+        consumeError(NameOrErr.takeError());
+    } else {
+      Name = unwrapOrError(Symbol.getName(), o->getFileName());
+    }
+    if (Name == SymbolName)
+      return Address;
+  }
+  return 0;
+}
+
+uint64_t SectionOffset(const ObjectFile *o, StringRef secName) {
+  for (const SectionRef &Section : o->sections()) {
+    StringRef Name;
+    uint64_t BaseAddr;
+    Name = unwrapOrError(Section.getName(), o->getFileName());
+    unwrapOrError(Section.getContents(), o->getFileName());
+    BaseAddr = Section.getAddress();
+
+    if (Name == secName)
+      return BaseAddr;
+  }
+  return 0;
+}
+
+using namespace llvm::elf2hex;
+
+Reader reader;
+
+VerilogHex::VerilogHex(std::unique_ptr<MCInstPrinter>& instructionPointer, 
+  std::unique_ptr<const MCSubtargetInfo>& subTargetInfo, const ObjectFile *Obj) :
+  IP(instructionPointer), STI(subTargetInfo) {
+  lastDumpAddr = 0;
+#ifdef ELF2HEX_DEBUG
+  //uint64_t startAddr = GetSectionHeaderStartAddress(Obj, "_start");
+  //errs() << format("_start address:%08" PRIx64 "\n", startAddr);
+#endif
+  uint64_t isrAddr = GetSymbolAddress(Obj, "ISR");
+  errs() << format("ISR address:%08" PRIx64 "\n", isrAddr);
+
+  //uint64_t pltOffset = SectionOffset(Obj, ".plt");
+  uint64_t textOffset = SectionOffset(Obj, ".text");
+  PrintBootSection(textOffset, isrAddr, LittleEndian);
+  lastDumpAddr = BOOT_SIZE;
+  Fill0s(lastDumpAddr, 0x100);
+  lastDumpAddr = 0x100;
+}
+
+void VerilogHex::PrintBootSection(uint64_t textOffset, uint64_t isrAddr, 
+                                  bool isLittleEndian) {
+  uint64_t offset = textOffset - 4;
+
+  // isr instruction at 0x8 and PC counter point to next instruction
+  uint64_t isrOffset = isrAddr - 8 - 4;
+  if (isLittleEndian) {
+    outs() << "/*       0:*/	";
+    outs() << format("%02" PRIx64 " ", (offset & 0xff));
+    outs() << format("%02" PRIx64 " ", (offset & 0xff00) >> 8);
+    outs() << format("%02" PRIx64 "", (offset & 0xff0000) >> 16);
+    outs() << " 36";
+    outs() << "                                  /*	jmp	0x";
+    outs() << format("%02" PRIx64 "%02" PRIx64 "%02" PRIx64 " */\n",
+      (offset & 0xff0000) >> 16, (offset & 0xff00) >> 8, (offset & 0xff));
+    outs() <<
+      "/*       4:*/	04 00 00 36                                  /*	jmp	4 */\n";
+    offset -= 8;
+    outs() << "/*       8:*/	";
+    outs() << format("%02" PRIx64 " ", (isrOffset & 0xff));
+    outs() << format("%02" PRIx64 " ", (isrOffset & 0xff00) >> 8);
+    outs() << format("%02" PRIx64 "", (isrOffset & 0xff0000) >> 16);
+    outs() << " 36";
+    outs() << "                                  /*	jmp	0x";
+    outs() << format("%02" PRIx64 "%02" PRIx64 "%02" PRIx64 " */\n",
+      (isrOffset & 0xff0000) >> 16, (isrOffset & 0xff00) >> 8, (isrOffset & 0xff));
+    outs() <<
+      "/*       c:*/	fc ff ff 36                                  /*	jmp	-4 */\n";
+  }
+  else {
+    outs() << "/*       0:*/	36 ";
+    outs() << format("%02" PRIx64 " ", (offset & 0xff0000) >> 16);
+    outs() << format("%02" PRIx64 " ", (offset & 0xff00) >> 8);
+    outs() << format("%02" PRIx64 "", (offset & 0xff));
+    outs() << "                                  /*	jmp	0x";
+    outs() << format("%02" PRIx64 "%02" PRIx64 "%02" PRIx64 " */\n",
+      (offset & 0xff0000) >> 16, (offset & 0xff00) >> 8, (offset & 0xff));
+    outs() <<
+      "/*       4:*/	36 00 00 04                                  /*	jmp	4 */\n";
+    offset -= 8;
+    outs() << "/*       8:*/	36 ";
+    outs() << format("%02" PRIx64 " ", (isrOffset & 0xff0000) >> 16);
+    outs() << format("%02" PRIx64 " ", (isrOffset & 0xff00) >> 8);
+    outs() << format("%02" PRIx64 "", (isrOffset & 0xff));
+    outs() << "                                  /*	jmp	0x";
+    outs() << format("%02" PRIx64 "%02" PRIx64 "%02" PRIx64 " */\n",
+      (isrOffset & 0xff0000) >> 16, (isrOffset & 0xff00) >> 8, (isrOffset & 0xff));
+    outs() <<
+      "/*       c:*/	36 ff ff fc                                  /*	jmp	-4 */\n";
+  }
+}
+
+// Fill /*address*/ 00 00 00 00 [startAddr..endAddr] from startAddr to endAddr. 
+// Include startAddr and endAddr.
+void VerilogHex::Fill0s(uint64_t startAddr, uint64_t endAddr) {
+  std::size_t addr;
+
+  assert((startAddr <= endAddr) && "startAddr must <= BaseAddr");
+  // Fill /*address*/ 00 00 00 00 for 4 bytes alignment (1 Cpu0 word size)
+  for (addr = startAddr; addr < endAddr; addr += 4) {
+    outs() << format("/*%8" PRIx64 " */", addr);
+    outs() << format("%02" PRIx64 " ", 0) << format("%02" PRIx64 " ", 0) \
+    << format("%02" PRIx64 " ", 0) << format("%02" PRIx64 " ", 0) << '\n';
+  }
+
+  return;
+}
+
+void VerilogHex::ProcessDisAsmInstruction(MCInst inst, uint64_t Size, 
+                                ArrayRef<uint8_t> Bytes, const ObjectFile *Obj) {
+  SectionRef Section = reader.CurrentSection();
+  StringRef Name;
+  StringRef Contents;
+  Name = unwrapOrError(Section.getName(), Obj->getFileName());
+  unwrapOrError(Section.getContents(), Obj->getFileName());
+  uint64_t SectionAddr = Section.getAddress();
+  uint64_t Index = reader.CurrentIndex();
+#ifdef ELF2HEX_DEBUG
+  errs() << format("SectionAddr + Index = %8" PRIx64 "\n", SectionAddr + Index);
+  errs() << format("lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
+#endif
+  if (lastDumpAddr < SectionAddr) {
+    Fill0s(lastDumpAddr, SectionAddr - 1);
+    lastDumpAddr = SectionAddr;
+  }
+
+  // print section name when meeting it first time
+  if (sectionName != Name) {
+    StringRef SegmentName = "";
+    if (const MachOObjectFile *MachO =
+        dyn_cast<const MachOObjectFile>(Obj)) {
+      DataRefImpl DR = Section.getRawDataRefImpl();
+      SegmentName = MachO->getSectionFinalSegmentName(DR);
+    }
+    outs() << "/*" << "Disassembly of section ";
+    if (!SegmentName.empty())
+      outs() << SegmentName << ",";
+    outs() << Name << ':' << "*/";
+    sectionName = Name;
+  }
+
+  if (si != reader.CurrentSi()) {
+    // print function name in section .text just before the first instruction 
+    // is printed
+    outs() << '\n' << "/*" << reader.CurrentSymbol() << ":*/\n";
+    si = reader.CurrentSi();
+  }
+
+  // print instruction address
+  outs() << format("/*%8" PRIx64 ":*/", SectionAddr + Index);
+ 
+  // print instruction in hex format
+  outs() << "\t";
+  dumpBytes(Bytes.slice(Index, Size), outs());
+
+  outs() << "/*";
+  // print disassembly instruction to outs()
+  IP->printInst(&inst, 0, "", *STI, outs());
+  outs() << "*/";
+  outs() << "\n";
+
+  // In section .plt or .text, the Contents.size() maybe < (SectionAddr + Index + 4)
+  if (Contents.size() < (SectionAddr + Index + 4))
+    lastDumpAddr = SectionAddr + Index + 4;
+  else
+    lastDumpAddr = SectionAddr + Contents.size();
+}
+
+void VerilogHex::ProcessDataSection(SectionRef Section) {
+  std::string Error;
+  StringRef Name;
+  StringRef Contents;
+  uint64_t BaseAddr;
+  uint64_t size;
+  getName(Section, Name);
+  unwrapOrError(Section.getContents(), CurrInputFile);
+  BaseAddr = Section.getAddress();
+
+#ifdef ELF2HEX_DEBUG
+  errs() << format("BaseAddr = %8" PRIx64 "\n", BaseAddr);
+  errs() << format("lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
+#endif
+  if (lastDumpAddr < BaseAddr) {
+    Fill0s(lastDumpAddr, BaseAddr - 1);
+    lastDumpAddr = BaseAddr;
+  }
+  if ((Name == ".bss" || Name == ".sbss") && Contents.size() > 0) {
+    size = (Contents.size() + 3)/4*4;
+    Fill0s(BaseAddr, BaseAddr + size - 1);
+    lastDumpAddr = BaseAddr + size;
+    return;
+  }
+  else {
+    PrintDataSection(Section);
+  }
+}
+
+void VerilogHex::PrintDataSection(SectionRef Section) {
+  std::string Error;
+  StringRef Name;
+  uint64_t BaseAddr;
+  uint64_t size;
+  getName(Section, Name);
+  StringRef Contents = unwrapOrError(Section.getContents(), CurrInputFile);
+  BaseAddr = Section.getAddress();
+
+  if (Contents.size() <= 0) {
+    return;
+  }
+  size = (Contents.size()+3)/4*4;
+
+  outs() << "/*Contents of section " << Name << ":*/\n";
+  // Dump out the content as hex and printable ascii characters.
+  for (std::size_t addr = 0, end = Contents.size(); addr < end; addr += 16) {
+    outs() << format("/*%8" PRIx64 " */", BaseAddr + addr);
+    // Dump line of hex.
+    for (std::size_t i = 0; i < 16; ++i) {
+      if (i != 0 && i % 4 == 0)
+        outs() << ' ';
+      if (addr + i < end)
+        outs() << hexdigit((Contents[addr + i] >> 4) & 0xF, true)
+               << hexdigit(Contents[addr + i] & 0xF, true) << " ";
+    }
+    // Print ascii.
+    outs() << "/*" << "  ";
+    for (std::size_t i = 0; i < 16 && addr + i < end; ++i) {
+      if (std::isprint(static_cast<unsigned char>(Contents[addr + i]) & 0xFF))
+        outs() << Contents[addr + i];
+      else
+        outs() << ".";
+    }
+    outs() << "*/" << "\n";
+  }
+  for (std::size_t i = Contents.size(); i < size; i++) {
+    outs() << "00 ";
+  }
+  outs() << "\n";
+#ifdef ELF2HEX_DEBUG
+  errs() << "Name " << Name << "  BaseAddr ";
+  errs() << format("%8" PRIx64 " Contents.size() ", BaseAddr);
+  errs() << format("%8" PRIx64 " size ", Contents.size());
+  errs() << format("%8" PRIx64 " \n", size);
+#endif
+  // save the end address of this section to lastDumpAddr
+  lastDumpAddr = BaseAddr + size;
+}
+
+StringRef Reader::CurrentSymbol() {
+  return Symbols[si].second;
+}
+
+SectionRef Reader::CurrentSection() {
+  return _section;
+}
+
+unsigned Reader::CurrentSi() {
+  return si;
+}
+
+uint64_t Reader::CurrentIndex() {
+  return Index;
+}
+
+// Porting from DisassembleObject() of llvm-objump.cpp
+void Reader::DisassembleObject(const ObjectFile *Obj
+/*, bool InlineRelocs*/  , std::unique_ptr<MCDisassembler>& DisAsm, 
+  std::unique_ptr<MCInstPrinter>& IP,
+  std::unique_ptr<const MCSubtargetInfo>& STI) {
+  VerilogHex hexOut(IP, STI, Obj);
+  std::error_code ec;
+  for (const SectionRef &Section : Obj->sections()) {
+    _section = Section;
+    uint64_t BaseAddr;
+    unwrapOrError(Section.getContents(), Obj->getFileName());
+    BaseAddr = Section.getAddress();
+    uint64_t SectSize = Section.getSize();
+    if (!SectSize)
+      continue;
+
+    if (BaseAddr < 0x100)
+      continue;
+ 
+  #ifdef ELF2HEX_DEBUG
+    StringRef SectionName = unwrapOrError(Section.getName(), Obj->getFileName());
+    errs() << "SectionName " << SectionName << format("  BaseAddr %8" PRIx64 "\n", BaseAddr);
+  #endif
+ 
+    bool text;
+    text = Section.isText();
+    if (!text) {
+      hexOut.ProcessDataSection(Section);
+      continue;
+    }
+    // It's .text section
+    uint64_t SectionAddr;
+    SectionAddr = Section.getAddress();
+ 
+    // Make a list of all the symbols in this section.
+    for (const SymbolRef &Symbol : Obj->symbols()) {
+      if (Section.containsSymbol(Symbol)) {
+        Expected<uint64_t> AddressOrErr = Symbol.getAddress();
+        error(errorToErrorCode(AddressOrErr.takeError()));
+        uint64_t Address = *AddressOrErr;
+        Address -= SectionAddr;
+        if (Address >= SectSize)
+          continue;
+
+        Expected<StringRef> Name = Symbol.getName();
+        error(errorToErrorCode(Name.takeError()));
+        Symbols.push_back(std::make_pair(Address, *Name));
+      }
+    }
+
+    // Sort the symbols by address, just in case they didn't come in that way.
+    array_pod_sort(Symbols.begin(), Symbols.end());
+  #ifdef ELF2HEX_DEBUG
+    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
+        errs() << '\n' << "/*" << Symbols[si].first << "  " << Symbols[si].second << ":*/\n";
+    }
+  #endif
+
+    // Make a list of all the relocations for this section.
+    std::vector<RelocationRef> Rels;
+
+    // Sort relocations by address.
+    std::sort(Rels.begin(), Rels.end(), isRelocAddressLess);
+
+    StringRef name;
+    getName(Section, name);
+
+    // If the section has no symbols just insert a dummy one and disassemble
+    // the whole section.
+    if (Symbols.empty())
+      Symbols.push_back(std::make_pair(0, name));
+
+    SmallString<40> Comments;
+    raw_svector_ostream CommentStream(Comments);
+
+    ArrayRef<uint8_t> Bytes = arrayRefFromStringRef(
+        unwrapOrError(Section.getContents(), Obj->getFileName()));
+#if 0
+    Section.getContents();
+    ArrayRef<uint8_t> Bytes(reinterpret_cast<const uint8_t *>(BytesStr.data()),
+                            BytesStr.size());
+#endif
+    uint64_t Size;
+    SectSize = Section.getSize();
+
+    // Disassemble symbol by symbol.
+    unsigned se;
+    for (si = 0, se = Symbols.size(); si != se; ++si) {
+      uint64_t Start = Symbols[si].first;
+      uint64_t End;
+      // The end is either the size of the section or the beginning of the next
+      // symbol.
+      if (si == se - 1)
+        End = SectSize;
+      // Make sure this symbol takes up space.
+      else if (Symbols[si + 1].first != Start)
+        End = Symbols[si + 1].first - 1;
+      else {
+        continue;
+      }
+
+      for (Index = Start; Index < End; Index += Size) {
+        MCInst Inst;
+        if (DisAsm->getInstruction(Inst, Size, Bytes.slice(Index),
+                                   SectionAddr + Index, CommentStream)) {
+          hexOut.ProcessDisAsmInstruction(Inst, Size, Bytes, Obj);
+        } else {
+          errs() << ToolName << ": warning: invalid instruction encoding\n";
+          if (Size == 0)
+            Size = 1; // skip illegible bytes
+        }
+      } // for
+    } // for
+  }
+}
+
+// Porting from disassembleObject() of llvm-objump.cpp
+static void Elf2Hex(const ObjectFile *Obj) {
+
+  const Target *TheTarget = getTarget(Obj);
+
+  // Package up features to be passed to target/subtarget
+  SubtargetFeatures Features = Obj->getFeatures();
+
+  std::unique_ptr<const MCRegisterInfo> MRI(TheTarget->createMCRegInfo(TripleName));
+  if (!MRI)
+    report_fatal_error("error: no register info for target " + TripleName);
+
+  // Set up disassembler.
+  MCTargetOptions MCOptions;
+  std::unique_ptr<const MCAsmInfo> AsmInfo(
+    TheTarget->createMCAsmInfo(*MRI, TripleName, MCOptions));
+  if (!AsmInfo)
+    report_fatal_error("error: no assembly info for target " + TripleName);
+
+  std::unique_ptr<const MCSubtargetInfo> STI(
+    TheTarget->createMCSubtargetInfo(TripleName, "", Features.getString()));
+  if (!STI)
+    report_fatal_error("error: no subtarget info for target " + TripleName);
+
+  std::unique_ptr<const MCInstrInfo> MII(TheTarget->createMCInstrInfo());
+  if (!MII)
+    report_fatal_error("error: no instruction info for target " + TripleName);
+
+  MCObjectFileInfo MOFI;
+  MCContext Ctx(AsmInfo.get(), MRI.get(), &MOFI);
+  // FIXME: for now initialize MCObjectFileInfo with default values
+  MOFI.InitMCObjectFileInfo(Triple(TripleName), false, Ctx);
+
+  std::unique_ptr<MCDisassembler> DisAsm(
+    TheTarget->createMCDisassembler(*STI, Ctx));
+  if (!DisAsm)
+    report_fatal_error("error: no disassembler for target " + TripleName);
+
+  std::unique_ptr<const MCInstrAnalysis> MIA(
+      TheTarget->createMCInstrAnalysis(MII.get()));
+
+  int AsmPrinterVariant = AsmInfo->getAssemblerDialect();
+  std::unique_ptr<MCInstPrinter> IP(TheTarget->createMCInstPrinter(
+      Triple(TripleName), AsmPrinterVariant, *AsmInfo, *MII, *MRI));
+  if (!IP)
+    report_fatal_error("error: no instruction printer for target " +
+                       TripleName);
+
+  std::error_code EC;
+  reader.DisassembleObject(Obj, DisAsm, IP, STI);
+}
+
+static void DumpObject(const ObjectFile *o) {
+  outs() << "/*";
+  outs() << o->getFileName()
+         << ":\tfile format " << o->getFileFormatName() << "*/";
+  outs() << "\n\n";
+
+  Elf2Hex(o);
+}
+
+/// @brief Open file and figure out how to dump it.
+static void DumpInput(StringRef file) {
+  CurrInputFile = file;
+  // Attempt to open the binary.
+  Expected<OwningBinary<Binary>> BinaryOrErr = createBinary(file);
+  if (!BinaryOrErr)
+    reportError(file, "no this file");
+
+  Binary &Binary = *BinaryOrErr.get().getBinary();
+
+  if (ObjectFile *o = dyn_cast<ObjectFile>(&Binary))
+    DumpObject(o);
+  else
+    reportError(file, "invalid_file_type");
+}
+
+int main(int argc, char **argv) {
+  // Print a stack trace if we signal out.
+  //sys::PrintStackTraceOnErrorSignal(argv[0]);
+  //PrettyStackTraceProgram X(argc, argv);
+  //llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
+
+  using namespace llvm;
+  InitLLVM X(argc, argv);
+
+  // Initialize targets and assembly printers/parsers.
+  llvm::InitializeAllTargetInfos();
+  llvm::InitializeAllTargetMCs();
+  llvm::InitializeAllDisassemblers();
+
+  // Register the target printer for --version.
+  cl::AddExtraVersionPrinter(TargetRegistry::printRegisteredTargetsForVersion);
+
+  cl::ParseCommandLineOptions(argc, argv, "llvm object file dumper\n");
+//  TripleName = Triple::normalize(TripleName);
+
+  ToolName = argv[0];
+
+  // Defaults to a.out if no filenames specified.
+  if (InputFilenames.size() == 0)
+    InputFilenames.push_back("a.out");
+
+  std::for_each(InputFilenames.begin(), InputFilenames.end(),
+                DumpInput);
+
+  return EXIT_SUCCESS;
+}
+
diff -Nrup orig/llvm/tools/elf2hex/elf2hex.h modify/llvm/tools/elf2hex/elf2hex.h
--- orig/llvm/tools/elf2hex/elf2hex.h	1970-01-01 08:00:00.000000000 +0800
+++ modify/llvm/tools/elf2hex/elf2hex.h	2023-04-26 15:15:07.000000000 +0800
@@ -0,0 +1,87 @@
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TOOLS_ELF2HEX_ELF2HEX_H
+#define LLVM_TOOLS_ELF2HEX_ELF2HEX_H
+
+#include "llvm/DebugInfo/DIContext.h"
+#include "llvm/MC/MCDisassembler/MCDisassembler.h"
+#include "llvm/MC/MCInstPrinter.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Compiler.h"
+#include "llvm/Support/DataTypes.h"
+#include "llvm/Object/Archive.h"
+
+#include <stdio.h>
+#include "llvm/Support/raw_ostream.h"
+
+#define BOOT_SIZE 16
+
+#define DLINK
+//#define ELF2HEX_DEBUG
+
+namespace llvm {
+
+namespace elf2hex {
+
+using namespace object;
+
+class HexOut {
+public:
+  virtual void ProcessDisAsmInstruction(MCInst inst, uint64_t Size, 
+                                ArrayRef<uint8_t> Bytes, const ObjectFile *Obj) = 0;
+  virtual void ProcessDataSection(SectionRef Section) {};
+  virtual ~HexOut() {};
+};
+
+// Split HexOut from Reader::DisassembleObject() for separating hex output 
+// functions.
+class VerilogHex : public HexOut {
+public:
+  VerilogHex(std::unique_ptr<MCInstPrinter>& instructionPointer, 
+             std::unique_ptr<const MCSubtargetInfo>& subTargetInfo,
+             const ObjectFile *Obj);
+  void ProcessDisAsmInstruction(MCInst inst, uint64_t Size, 
+                                ArrayRef<uint8_t> Bytes, const ObjectFile *Obj) override;
+  void ProcessDataSection(SectionRef Section) override;
+
+private:
+  void PrintBootSection(uint64_t textOffset, uint64_t isrAddr, bool isLittleEndian);
+  void Fill0s(uint64_t startAddr, uint64_t endAddr);
+  void PrintDataSection(SectionRef Section);
+  std::unique_ptr<MCInstPrinter>& IP;
+  std::unique_ptr<const MCSubtargetInfo>& STI;
+  uint64_t lastDumpAddr;
+  unsigned si;
+  StringRef sectionName;
+};
+
+class Reader {
+public:
+  void DisassembleObject(const ObjectFile *Obj, 
+                         std::unique_ptr<MCDisassembler>& DisAsm, 
+                         std::unique_ptr<MCInstPrinter>& IP, 
+                         std::unique_ptr<const MCSubtargetInfo>& STI);
+  StringRef CurrentSymbol();
+  SectionRef CurrentSection();
+  unsigned CurrentSi();
+  uint64_t CurrentIndex();
+
+private:
+  SectionRef _section;
+  std::vector<std::pair<uint64_t, StringRef> > Symbols;
+  unsigned si;
+  uint64_t Index;
+};
+
+} // end namespace elf2hex
+} // end namespace llvm
+
+//using namespace llvm;
+
+#endif
diff -Nrup orig/llvm/tools/llvm-objdump/llvm-objdump.cpp modify/llvm/tools/llvm-objdump/llvm-objdump.cpp
--- orig/llvm/tools/llvm-objdump/llvm-objdump.cpp	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/tools/llvm-objdump/llvm-objdump.cpp	2023-04-26 15:15:07.000000000 +0800
@@ -1877,7 +1877,8 @@ static void disassembleObject(const Targ
       if (Obj->isXCOFF() && SymbolDescription) {
         outs() << getXCOFFSymbolDescription(Symbols[SI], SymbolName) << ":\n";
       } else
-        outs() << '<' << SymbolName << ">:\n";
+        outs() << "/* " << SymbolName << ":*/\n"; // For Cpu0
+
 
       // Don't print raw contents of a virtual section. A virtual section
       // doesn't have any contents in the file.
@@ -2950,6 +2951,7 @@ static void dumpInput(StringRef file) {
     reportError(errorCodeToError(object_error::invalid_file_type), file);
 }
 
+#ifndef ELF2HEX
 int main(int argc, char **argv) {
   using namespace llvm;
   InitLLVM X(argc, argv);
@@ -3010,3 +3012,4 @@ int main(int argc, char **argv) {
 
   return EXIT_SUCCESS;
 }
+#endif
diff -Nrup orig/llvm/utils/gn/secondary/llvm/lib/Target/targets.gni modify/llvm/utils/gn/secondary/llvm/lib/Target/targets.gni
--- orig/llvm/utils/gn/secondary/llvm/lib/Target/targets.gni	2023-04-26 15:15:07.000000000 +0800
+++ modify/llvm/utils/gn/secondary/llvm/lib/Target/targets.gni	2023-04-26 15:15:07.000000000 +0800
@@ -15,6 +15,7 @@ llvm_all_targets = [
   "Hexagon",
   "Lanai",
   "Mips",
+  "Cpu0",
   "NVPTX",
   "PowerPC",
   "RISCV",
@@ -48,6 +49,7 @@ llvm_build_AMDGPU = false
 llvm_build_ARM = false
 llvm_build_BPF = false
 llvm_build_Mips = false
+llvm_build_Cpu0 = false
 llvm_build_PowerPC = false
 llvm_build_WebAssembly = false
 llvm_build_X86 = false
@@ -62,6 +64,8 @@ foreach(target, llvm_targets_to_build) {
     llvm_build_BPF = true
   } else if (target == "Mips") {
     llvm_build_Mips = true
+  } else if (target == "Cpu0") {
+    llvm_build_Cpu0 = true
   } else if (target == "PowerPC") {
     llvm_build_PowerPC = true
   } else if (target == "WebAssembly") {
